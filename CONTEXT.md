## Big Picture

You have a target protein (a string over the 20 amino acids). You want to change its sequence so some property improves—stability, activity, binding, solubility, expression, etc.—while keeping it folded and functional. Your system is building an AI co-pilot for protein engineering. Steps:
- Retrieve knowledge from nature (homologs, conserved positions, known motifs/constraints, structure hints).
- Design sequence edits (mutations) that are plausible given biology and aligned to your goal.
- Evaluate & rank candidates with cheap in-silico filters; then hand the best to the wet lab.

## Background Info
- Sequence → Structure → Function. A protein is a polymer of amino acids. The sequence (primary structure) folds into a 3D conformation (secondary/tertiary). Function emerges from that fold.
- Amino acids differ in size, charge, hydrophobicity, and special roles (e.g., Cys makes disulfide bonds; Pro bends backbones; Gly is flexible; His often catalyzes).
- Conservation encodes importance. Positions that barely change across evolution are likely critical (active site, structural core). Positions that vary are more tolerant to mutation.
- Fitness landscape & epistasis. Each mutation moves you on a rugged landscape; effects can interact (A is good alone, bad with B). Start with single mutants and keep combinations small unless you have strong prior.
- Trade-offs are real. Stabilizing mutations can hurt activity; solubility can fight binding; expression can oppose secretion efficiency. Know your primary KPI.

## Data

- Homologous sequences & multiple sequence alignments (MSA). Nature’s A/B tests. Show which residues are conserved vs variable; reveal consensus residues and co-varying positions.
- Substitution matrices (e.g., BLOSUM/PAM). Empirical log-odds for swapping residue X→Y based on what evolution tolerates in aligned positions. High score = conservative (safe-ish).
- Structure / structure confidence. Experimental (PDB) or predicted (e.g., AlphaFold). Lets you reason about core vs surface, loops vs helices, interfaces, disulfides, active sites.
- Annotations/motifs. Domains, catalytic residues, signal peptides, transmembrane spans, glycosylation motifs (N-X-S/T), low-complexity or aggregation-prone regions.


## Workflow - Agents in the Multi-Agent System

### Retrieval Agent

**Goal:** Pull in “priors” from biology so design isn’t blind.

1. **Homolog search** (BLAST/HHblits-like) for your target sequence.
2. **Build an MSA** (deduplicate, filter close/remote hits, balance clades).
3. **Per-position statistics**:

   * Frequency (f_{i,a}) of amino acid (a) at position (i)
   * **Conservation** (Shannon entropy) (H_i=-\sum_a f_{i,a}\log f_{i,a})
   * **Consensus** residue (c_i=\arg\max_a f_{i,a})
4. **Constraint extraction**: mark high-conservation sites, catalytic motifs, cystines/disulfides, glycosylation sites, signal peptides, TM spans, interface residues (from structure, if available).
5. **Optionally** compute **PSSM** (position-specific scoring) and/or co-variation hints to avoid breaking pairwise contacts.

**Outputs:** an “evidence pack” your designer can use:

* MSA + per-position conservation/consensus
* A “do-not-touch” mask (active site, disulfides, glyco, catalytic H/D/E, metal-binding)
* Region annotations (core vs surface, loop vs helix) if structure is present
* Optional thermostable homolog shortlist (if your KPI is stability)


# Archived Explanation to get back to later - Generated by GPT


### Design Agent
**Goal:** Propose plausible mutations with guardrails.

Two design modes:

1. **Consensus / conservative edits (fast, safe baseline).**

   * For low-conservation positions ((H_i) high), suggest moving the target residue toward **consensus** (c_i).
   * Use **BLOSUM/PAM** to restrict to **conservative** substitutions (positive log-odds).
   * Skip protected positions (active site, disulfides, glyco motifs, TM core).
   * Great for **stability/expressibility** improvements with low risk.

2. **Model-guided proposals (smarter, goal-aware).**

   * **Protein language models** (e.g., ProtGPT-style) score the likelihood of residue choices in context; high-likelihood edits tend to be fold-compatible.
   * **Structure-aware designers** (e.g., ProteinMPNN-style) propose sidechain identities that pack well into a backbone—useful for stabilizing cores or interfaces.

**Ranking/filters your designer should apply now (cheap and effective):**

* Penalize changes at **highly conserved** or **annotated** residues.
* Favor **BLOSUM-positive** swaps; downrank radical physicochemical jumps (e.g., charged→hydrophobe in core).
* Prefer **surface** over **core** edits for first passes (less risk).
* Respect **sequence motifs** (N-X-S/T glyco; signal peptides; catalytic triads).
* Keep initial library to **single mutants** or **very small combos**.

# how the agents collaborate (the loop you already have)

1. **Retrieval**: “Here’s the MSA, consensus per position, conservation, structural masks, and sensitive sites.”
2. **Design**: “Given those priors + your KPI, here are N mutation suggestions, each with a rationale and safety checks passed.”
3. **(Soon) Evaluation**: “Score ΔΔG/aggregation/solubility/LLM likelihood; triage to a short list.”
4. **(Optional) Active learning** after assays: feed measured fitness back into the design policy.

# what you’ve effectively accomplished so far

* **You’re not designing in a vacuum.** Proposals are anchored in evolution (consensus + substitution matrices) and guided by “what nature already tried.”
* **You’ve added guardrails.** Catalytic/disulfide/glyco/TM constraints prevent catastrophic edits.
* **You can generate sane, diverse first-pass libraries** (dozens to a few hundred single-point suggestions) that are cheap to synthesize/test and likely to keep the fold intact.
* **You’re set up to plug in smarter scoring** (language-model or structure-aware) without changing the outer loop.

# a bit more math (so the heuristics feel principled)

* **Conservation (entropy):** low (H_i) ⇒ critical site; high (H_i) ⇒ tolerant.
* **PSSM** score for proposing (a) at (i): (S_{i,a}=\log \frac{f_{i,a}}{p_a}) (vs background).
* **BLOSUM log-odds** (L(x\to y)): positive = commonly tolerated swap; negative = historically disfavored.
* A simple **composite score** you can implement now per mutation ((i:x\to y)):
  [
  \text{Score} = w_1 \cdot L(x\to y) + w_2 \cdot S_{i,y} - w_3 \cdot \mathbb{1}[\text{conserved/annotated}] - w_4 \cdot \Delta\text{physchem}
  ]
  (tune (w_k); set the indicator penalty very large for “do-not-touch”.)

# practical constraints your designer should already respect

* **Disulfides:** never mutate Cys in a Cys–Cys pair unless you redesign both.
* **Catalytic/ligand sites:** keep the triad/metal chelators intact (commonly Ser/His/Asp; His/Glu/Asp for metals).
* **Glycosylation motif (N-X-S/T):** don’t break it if glycosylation matters—or *do* remove if your KPI is “no glyco.”
* **Signal peptides / TM segments:** hydrophobicity patterns are essential; avoid polar swaps in TM cores.
* **Stop codons & restriction sites** (downstream DNA step): avoid introducing them inadvertently.

# example: if your KPI is “more stable & better expressed”

* Retrieval: enrich MSA with **thermophilic homologs**; compute consensus; map **core vs surface** from structure.
* Design: prefer **consensus or conservative** swaps on **surface loops**, avoid fully conserved positions, propose hydrophobic→polar on solvent-exposed sticky patches to reduce aggregation; propose small-to-medium core packing fixes only if structure-aware scoring is available.
* Output: a ranked list of single-point edits with rationales like “A123S: matches consensus; BLOSUM +1; surface loop; reduces local hydrophobic patch.”

# common pitfalls (so you don’t chase ghosts)

* **Dirty MSAs** (paralogs, fragments) can fake “conservation” or “variability.” Filter length/identity and ensure domain boundaries align.
* **Domain boundaries**: editing across a linker vs inside a catalytic pocket is night-and-day risk.
* **Over-combining single hits**: additive is not guaranteed—watch epistasis.
* **Objective creep**: mixing multiple KPIs without a scoring rubric leads to noisy libraries.

# sensible next steps (when you’re ready)

1. **Evaluation agent (cheap first):**

   * Sequence-only scores: LM likelihood / perplexity deltas, heuristic aggregation/solubility predictors, isoelectric point shifts, net charge at pH.
   * Rule-based vetoes: motif breaks, Cys handling, TM polarity, glyco disruptions.
2. **Structure-aware scoring (if you have a model/backbone):**

   * Rapid ΔΔG or pack-quality proxies; interface clash checks if it’s a complex.
3. **Design “policies” by KPI:** Stability policy, solubility policy, expression policy—each with different weights/filters.
4. **Reporting & export:** FASTA of variants, CSV rationale table, optional DNA codon optimization for your expression system.

---

If you want, I can turn this into **concrete scoring/ranking code** that plugs right into your existing retrieval/design agents: read MSA stats + BLOSUM, apply masks, generate candidates, compute the composite score, and emit a tidy DataFrame ready for triage.
